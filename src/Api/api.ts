/* tslint:disable */
/* eslint-disable */
/**
 * idmsvc-backend
 * Backend API for Directory & Domain Services
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Certificate
 */
export interface Certificate {
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  issuer: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  nickname: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  not_after: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  not_before: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  pem: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  serial_number: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  subject: string;
}
/**
 * A domain resource
 * @export
 * @interface Domain
 */
export interface Domain {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof Domain
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof Domain
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof Domain
   */
  auto_enrollment_enabled?: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof Domain
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof Domain
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof Domain
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof Domain
   */
  'rhel-idm'?: DomainIpa;
}

/**
 * Options for ipa domains
 * @export
 * @interface DomainIpa
 */
export interface DomainIpa {
  /**
   * List of auto-enrollment enabled servers for this domain.
   * @type {Array<DomainIpaServer>}
   * @memberof DomainIpa
   */
  servers: Array<DomainIpaServer>;
  /**
   * List of automount locations for AutoFS
   * @type {Array<string>}
   * @memberof DomainIpa
   */
  automount_locations?: Array<string>;
  /**
   * A base64 representation of all the list of chain of certificates, including the server ca.
   * @type {Array<Certificate>}
   * @memberof DomainIpa
   */
  ca_certs: Array<Certificate>;
  /**
   * List of DNS locations
   * @type {Array<Location>}
   * @memberof DomainIpa
   */
  locations: Array<Location>;
  /**
   * List of realm associated to the IPA domain.
   * @type {Array<string>}
   * @memberof DomainIpa
   */
  realm_domains: Array<string>;
  /**
   * A Kerberos realm name (usually all upper-case domain name). The realm can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof DomainIpa
   */
  realm_name: string;
}
/**
 * Server schema for an entry into the Ipa domain type.
 * @export
 * @interface DomainIpaServer
 */
export interface DomainIpaServer {
  /**
   *
   * @type {boolean}
   * @memberof DomainIpaServer
   */
  ca_server: boolean;
  /**
   * A host\'s Fully Qualified Domain Name (all lower-case).
   * @type {string}
   * @memberof DomainIpaServer
   */
  fqdn: string;
  /**
   *
   * @type {boolean}
   * @memberof DomainIpaServer
   */
  hcc_enrollment_server: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DomainIpaServer
   */
  hcc_update_server: boolean;
  /**
   * A location identifier (lower-case DNS label)
   * @type {string}
   * @memberof DomainIpaServer
   */
  location?: string;
  /**
   *
   * @type {boolean}
   * @memberof DomainIpaServer
   */
  pkinit_server: boolean;
  /**
   * A Red Hat Subcription Manager ID of a RHEL host.
   * @type {string}
   * @memberof DomainIpaServer
   */
  subscription_manager_id?: string;
}
/**
 * A domain registration response
 * @export
 * @interface DomainRegToken
 */
export interface DomainRegToken {
  /**
   * A domain id
   * @type {string}
   * @memberof DomainRegToken
   */
  domain_id: string;
  /**
   * A domain registration token string
   * @type {string}
   * @memberof DomainRegToken
   */
  domain_token: string;
  /**
   *
   * @type {DomainType}
   * @memberof DomainRegToken
   */
  domain_type: DomainType;
  /**
   * Expiration time stamp (Unix timestamp)
   * @type {number}
   * @memberof DomainRegToken
   */
  expiration: number;
}

/**
 * A domain registration request
 * @export
 * @interface DomainRegTokenRequest
 */
export interface DomainRegTokenRequest {
  /**
   *
   * @type {DomainType}
   * @memberof DomainRegTokenRequest
   */
  domain_type: DomainType;
}

/**
 * TODO
 * @export
 * @interface DomainRegisterResponse
 */
export interface DomainRegisterResponse {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof DomainRegisterResponse
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof DomainRegisterResponse
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof DomainRegisterResponse
   */
  auto_enrollment_enabled?: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof DomainRegisterResponse
   */
  domain_id: string;
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof DomainRegisterResponse
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof DomainRegisterResponse
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof DomainRegisterResponse
   */
  'rhel-idm'?: DomainIpa;
}

/**
 * A domain resource
 * @export
 * @interface DomainResponse
 */
export interface DomainResponse {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof DomainResponse
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof DomainResponse
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof DomainResponse
   */
  auto_enrollment_enabled: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof DomainResponse
   */
  domain_id: string;
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof DomainResponse
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof DomainResponse
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof DomainResponse
   */
  'rhel-idm'?: DomainIpa;
}

/**
 * Type of domain (currently only rhel-idm)
 * @export
 * @enum {string}
 */

export const DomainType = {
  RhelIdm: 'rhel-idm',
} as const;

export type DomainType = (typeof DomainType)[keyof typeof DomainType];

/**
 * TODO
 * @export
 * @interface DomainUpdateResponse
 */
export interface DomainUpdateResponse {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof DomainUpdateResponse
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof DomainUpdateResponse
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof DomainUpdateResponse
   */
  auto_enrollment_enabled: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof DomainUpdateResponse
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof DomainUpdateResponse
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof DomainUpdateResponse
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof DomainUpdateResponse
   */
  'rhel-idm'?: DomainIpa;
}

/**
 *
 * @export
 * @interface ErrorInfo
 */
export interface ErrorInfo {
  /**
   * The human-readable HTTP status text for the error.
   * @type {string}
   * @memberof ErrorInfo
   */
  title: string;
  /**
   * an application-specific error code
   * @type {string}
   * @memberof ErrorInfo
   */
  code?: string;
  /**
   * A detailed explanation of the error, e.g. traceback.
   * @type {string}
   * @memberof ErrorInfo
   */
  detail?: string;
  /**
   * a unique identifier for this particular occurrence of the problem.
   * @type {string}
   * @memberof ErrorInfo
   */
  id: string;
  /**
   * The HTTP status code for the error.
   * @type {string}
   * @memberof ErrorInfo
   */
  status: string;
}
/**
 * General error response returned by the idmsvc API
 * @export
 * @interface Errors
 */
export interface Errors {
  /**
   * Error objects provide additional information about problems encountered while performing an operation.
   * @type {Array<ErrorInfo>}
   * @memberof Errors
   */
  errors: Array<ErrorInfo>;
}
/**
 * Represent the request payload for the /host-conf/:inventory_id/:fqdn endpoint.
 * @export
 * @interface HostConf
 */
export interface HostConf {
  /**
   * A domain id
   * @type {string}
   * @memberof HostConf
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof HostConf
   */
  domain_name?: string;
  /**
   *
   * @type {DomainType}
   * @memberof HostConf
   */
  domain_type?: DomainType;
}

/**
 * Options for ipa domains
 * @export
 * @interface HostConfIpa
 */
export interface HostConfIpa {
  /**
   * Automount location name for ipa-client-automount
   * @type {string}
   * @memberof HostConfIpa
   */
  automount_location?: string;
  /**
   * A string of concatenated, PEM-encoded X.509 certificates
   * @type {string}
   * @memberof HostConfIpa
   */
  cabundle: string;
  /**
   * List of auto-enrollment enabled servers for this domain.
   * @type {Array<HostConfIpaServer>}
   * @memberof HostConfIpa
   */
  enrollment_servers: Array<HostConfIpaServer>;
  /**
   * List of additional arguments for ipa-client-install
   * @type {Array<string>}
   * @memberof HostConfIpa
   */
  ipa_client_install_args?: Array<string>;
  /**
   * A Kerberos realm name (usually all upper-case domain name). The realm can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof HostConfIpa
   */
  realm_name: string;
}
/**
 * Auto-enrollment enabled server for this domain.
 * @export
 * @interface HostConfIpaServer
 */
export interface HostConfIpaServer {
  /**
   * A host\'s Fully Qualified Domain Name (all lower-case).
   * @type {string}
   * @memberof HostConfIpaServer
   */
  fqdn: string;
  /**
   * A location identifier (lower-case DNS label)
   * @type {string}
   * @memberof HostConfIpaServer
   */
  location?: string;
}
/**
 * The response for the action to retrieve the host vm information when it is being enrolled. This action is taken from the host vm.
 * @export
 * @interface HostConfResponseSchema
 */
export interface HostConfResponseSchema {
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof HostConfResponseSchema
   */
  auto_enrollment_enabled: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof HostConfResponseSchema
   */
  domain_id: string;
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof HostConfResponseSchema
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof HostConfResponseSchema
   */
  domain_type: DomainType;
  /**
   *
   * @type {HostConfIpa}
   * @memberof HostConfResponseSchema
   */
  'rhel-idm': HostConfIpa;
  /**
   * A serialized JWS token or JWT to authenticate a host registration request.
   * @type {string}
   * @memberof HostConfResponseSchema
   */
  token?: string;
}

/**
 * The data listed for the domains.
 * @export
 * @interface ListDomainsData
 */
export interface ListDomainsData {
  /**
   * Human-friendly title for the domain entry.
   * @type {string}
   * @memberof ListDomainsData
   */
  title: string;
  /**
   * Human-readable description of the domain entry.
   * @type {string}
   * @memberof ListDomainsData
   */
  description: string;
  /**
   *
   * @type {boolean}
   * @memberof ListDomainsData
   */
  auto_enrollment_enabled: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof ListDomainsData
   */
  domain_id: string;
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof ListDomainsData
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof ListDomainsData
   */
  domain_type: DomainType;
}

/**
 * Represent a paginated result for a list of domains
 * @export
 * @interface ListDomainsResponseSchema
 */
export interface ListDomainsResponseSchema {
  /**
   * The content for this page.
   * @type {Array<ListDomainsData>}
   * @memberof ListDomainsResponseSchema
   */
  data: Array<ListDomainsData>;
  /**
   *
   * @type {PaginationLinks}
   * @memberof ListDomainsResponseSchema
   */
  links: PaginationLinks;
  /**
   *
   * @type {PaginationMeta}
   * @memberof ListDomainsResponseSchema
   */
  meta: PaginationMeta;
}
/**
 * RHEL IdM server location
 * @export
 * @interface Location
 */
export interface Location {
  /**
   * A location identifier (lower-case DNS label)
   * @type {string}
   * @memberof Location
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  description?: string;
}
/**
 * Represent the navigation links for the data paginated.
 * @export
 * @interface PaginationLinks
 */
export interface PaginationLinks {
  /**
   * Reference to the first page of the request.
   * @type {string}
   * @memberof PaginationLinks
   */
  first?: string;
  /**
   * Reference to the last page of the request.
   * @type {string}
   * @memberof PaginationLinks
   */
  last?: string;
  /**
   * Reference to the next page of the request.
   * @type {string}
   * @memberof PaginationLinks
   */
  next?: string;
  /**
   * Reference to the previous page of the request.
   * @type {string}
   * @memberof PaginationLinks
   */
  previous?: string;
}
/**
 * Metadata for the paginated responses.
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
  /**
   * total records in the collection.
   * @type {number}
   * @memberof PaginationMeta
   */
  count: number;
  /**
   * Number of items per page.
   * @type {number}
   * @memberof PaginationMeta
   */
  limit: number;
  /**
   * Initial record of the page.
   * @type {number}
   * @memberof PaginationMeta
   */
  offset: number;
}
/**
 * A domain resource
 * @export
 * @interface RegisterDomainRequest
 */
export interface RegisterDomainRequest {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof RegisterDomainRequest
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof RegisterDomainRequest
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof RegisterDomainRequest
   */
  auto_enrollment_enabled?: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof RegisterDomainRequest
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof RegisterDomainRequest
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof RegisterDomainRequest
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof RegisterDomainRequest
   */
  'rhel-idm'?: DomainIpa;
}

/**
 * Serialized JWKs with revocation information
 * @export
 * @interface SigningKeysResponse
 */
export interface SigningKeysResponse {
  /**
   * An array of serialized JSON Web Keys (JWK strings)
   * @type {Array<string>}
   * @memberof SigningKeysResponse
   */
  keys: Array<string>;
  /**
   * An array of revoked key identifiers (JWK kid)
   * @type {Array<string>}
   * @memberof SigningKeysResponse
   */
  revoked_kids?: Array<string>;
}
/**
 * A domain resource
 * @export
 * @interface UpdateDomainAgentRequest
 */
export interface UpdateDomainAgentRequest {
  /**
   * A name of a domain (all lower-case). The domain name can only be set during initial registration and not be modified by updates.
   * @type {string}
   * @memberof UpdateDomainAgentRequest
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof UpdateDomainAgentRequest
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof UpdateDomainAgentRequest
   */
  'rhel-idm': DomainIpa;
}

/**
 * A domain resource
 * @export
 * @interface UpdateDomainUserRequest
 */
export interface UpdateDomainUserRequest {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof UpdateDomainUserRequest
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof UpdateDomainUserRequest
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof UpdateDomainUserRequest
   */
  auto_enrollment_enabled?: boolean;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Action to retrieve the host information for the host vm being enrolled.
     * @summary Get host vm information.
     * @param {string} inventoryId A Host-Based Inventory ID of the host.
     * @param {string} fqdn The full qualified domain name of the host.
     * @param {HostConf} hostConf Required information to take the action.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hostConf: async (
      inventoryId: string,
      fqdn: string,
      hostConf: HostConf,
      xRhInsightsRequestId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inventoryId' is not null or undefined
      assertParamExists('hostConf', 'inventoryId', inventoryId);
      // verify required parameter 'fqdn' is not null or undefined
      assertParamExists('hostConf', 'fqdn', fqdn);
      // verify required parameter 'hostConf' is not null or undefined
      assertParamExists('hostConf', 'hostConf', hostConf);
      const localVarPath = `/host-conf/{inventory_id}/{fqdn}`
        .replace(`{${'inventory_id'}}`, encodeURIComponent(String(inventoryId)))
        .replace(`{${'fqdn'}}`, encodeURIComponent(String(fqdn)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hostConf, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update the rhel-idm domain information.
     * @summary Update domain information by ipa-hcc agent.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {UpdateDomainAgentRequest} updateDomainAgentRequest Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDomainAgent: async (
      uuid: string,
      xRhIdmVersion: string,
      updateDomainAgentRequest: UpdateDomainAgentRequest,
      xRhInsightsRequestId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('updateDomainAgent', 'uuid', uuid);
      // verify required parameter 'xRhIdmVersion' is not null or undefined
      assertParamExists('updateDomainAgent', 'xRhIdmVersion', xRhIdmVersion);
      // verify required parameter 'updateDomainAgentRequest' is not null or undefined
      assertParamExists('updateDomainAgent', 'updateDomainAgentRequest', updateDomainAgentRequest);
      const localVarPath = `/domains/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      if (xRhIdmVersion != null) {
        localVarHeaderParameter['X-Rh-Idm-Version'] = String(xRhIdmVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateDomainAgentRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Action to retrieve the host information for the host vm being enrolled.
     * @summary Get host vm information.
     * @param {string} inventoryId A Host-Based Inventory ID of the host.
     * @param {string} fqdn The full qualified domain name of the host.
     * @param {HostConf} hostConf Required information to take the action.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hostConf(
      inventoryId: string,
      fqdn: string,
      hostConf: HostConf,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostConfResponseSchema>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hostConf(inventoryId, fqdn, hostConf, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update the rhel-idm domain information.
     * @summary Update domain information by ipa-hcc agent.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {UpdateDomainAgentRequest} updateDomainAgentRequest Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDomainAgent(
      uuid: string,
      xRhIdmVersion: string,
      updateDomainAgentRequest: UpdateDomainAgentRequest,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainAgent(
        uuid,
        xRhIdmVersion,
        updateDomainAgentRequest,
        xRhInsightsRequestId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ActionsApiFp(configuration);
  return {
    /**
     * Action to retrieve the host information for the host vm being enrolled.
     * @summary Get host vm information.
     * @param {string} inventoryId A Host-Based Inventory ID of the host.
     * @param {string} fqdn The full qualified domain name of the host.
     * @param {HostConf} hostConf Required information to take the action.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hostConf(
      inventoryId: string,
      fqdn: string,
      hostConf: HostConf,
      xRhInsightsRequestId?: string,
      options?: any
    ): AxiosPromise<HostConfResponseSchema> {
      return localVarFp.hostConf(inventoryId, fqdn, hostConf, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
    /**
     * Update the rhel-idm domain information.
     * @summary Update domain information by ipa-hcc agent.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {UpdateDomainAgentRequest} updateDomainAgentRequest Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDomainAgent(
      uuid: string,
      xRhIdmVersion: string,
      updateDomainAgentRequest: UpdateDomainAgentRequest,
      xRhInsightsRequestId?: string,
      options?: any
    ): AxiosPromise<DomainUpdateResponse> {
      return localVarFp
        .updateDomainAgent(uuid, xRhIdmVersion, updateDomainAgentRequest, xRhInsightsRequestId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
  /**
   * Action to retrieve the host information for the host vm being enrolled.
   * @summary Get host vm information.
   * @param {string} inventoryId A Host-Based Inventory ID of the host.
   * @param {string} fqdn The full qualified domain name of the host.
   * @param {HostConf} hostConf Required information to take the action.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActionsApi
   */
  public hostConf(inventoryId: string, fqdn: string, hostConf: HostConf, xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ActionsApiFp(this.configuration)
      .hostConf(inventoryId, fqdn, hostConf, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update the rhel-idm domain information.
   * @summary Update domain information by ipa-hcc agent.
   * @param {string} uuid The uuid that identify the domain.
   * @param {string} xRhIdmVersion ipa-hcc agent version
   * @param {UpdateDomainAgentRequest} updateDomainAgentRequest Information for an IPA domain so it is updated from the ipa-hcc agent.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActionsApi
   */
  public updateDomainAgent(
    uuid: string,
    xRhIdmVersion: string,
    updateDomainAgentRequest: UpdateDomainAgentRequest,
    xRhInsightsRequestId?: string,
    options?: AxiosRequestConfig
  ) {
    return ActionsApiFp(this.configuration)
      .updateDomainAgent(uuid, xRhIdmVersion, updateDomainAgentRequest, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Request a domain registration token
     * @summary Domain registration token request
     * @param {DomainRegTokenRequest} domainRegTokenRequest Domain registration request
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomainToken: async (
      domainRegTokenRequest: DomainRegTokenRequest,
      xRhInsightsRequestId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'domainRegTokenRequest' is not null or undefined
      assertParamExists('createDomainToken', 'domainRegTokenRequest', domainRegTokenRequest);
      const localVarPath = `/domains/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(domainRegTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an existing domain from the current organization.
     * @summary Delete domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain: async (uuid: string, xRhInsightsRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteDomain', 'uuid', uuid);
      const localVarPath = `/domains/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get signing keys and revokation information
     * @summary Signing keys
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSigningKeys: async (xRhInsightsRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/signing_keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * For the current organization, list all the domains that are being managed from console.dot
     * @summary List domains in the organization
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {number} [offset] pagination offset
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDomains: async (xRhInsightsRequestId?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/domains`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request the information for a specific domain of our organization.
     * @summary Read a domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDomain: async (uuid: string, xRhInsightsRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('readDomain', 'uuid', uuid);
      const localVarPath = `/domains/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Register a domain in the current organization.
     * @summary Register a domain.
     * @param {string} xRhIdmRegistrationToken One-time password to authenticate domain registration with ipa-hcc command.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {RegisterDomainRequest} registerDomainRequest Domain object to be registered.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerDomain: async (
      xRhIdmRegistrationToken: string,
      xRhIdmVersion: string,
      registerDomainRequest: RegisterDomainRequest,
      xRhInsightsRequestId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xRhIdmRegistrationToken' is not null or undefined
      assertParamExists('registerDomain', 'xRhIdmRegistrationToken', xRhIdmRegistrationToken);
      // verify required parameter 'xRhIdmVersion' is not null or undefined
      assertParamExists('registerDomain', 'xRhIdmVersion', xRhIdmVersion);
      // verify required parameter 'registerDomainRequest' is not null or undefined
      assertParamExists('registerDomain', 'registerDomainRequest', registerDomainRequest);
      const localVarPath = `/domains`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      // authentication x-rh-idm-registration-token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Idm-Registration-Token', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      if (xRhIdmRegistrationToken != null) {
        localVarHeaderParameter['X-Rh-Idm-Registration-Token'] = String(xRhIdmRegistrationToken);
      }

      if (xRhIdmVersion != null) {
        localVarHeaderParameter['X-Rh-Idm-Version'] = String(xRhIdmVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(registerDomainRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update the rhel-idm domain information.
     * @summary Update domain information by user.
     * @param {string} uuid The uuid that identify the domain.
     * @param {UpdateDomainUserRequest} updateDomainUserRequest Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDomainUser: async (
      uuid: string,
      updateDomainUserRequest: UpdateDomainUserRequest,
      xRhInsightsRequestId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('updateDomainUser', 'uuid', uuid);
      // verify required parameter 'updateDomainUserRequest' is not null or undefined
      assertParamExists('updateDomainUser', 'updateDomainUserRequest', updateDomainUserRequest);
      const localVarPath = `/domains/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateDomainUserRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration);
  return {
    /**
     * Request a domain registration token
     * @summary Domain registration token request
     * @param {DomainRegTokenRequest} domainRegTokenRequest Domain registration request
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDomainToken(
      domainRegTokenRequest: DomainRegTokenRequest,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainRegToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainToken(domainRegTokenRequest, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete an existing domain from the current organization.
     * @summary Delete domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDomain(
      uuid: string,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomain(uuid, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get signing keys and revokation information
     * @summary Signing keys
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSigningKeys(
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningKeysResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSigningKeys(xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * For the current organization, list all the domains that are being managed from console.dot
     * @summary List domains in the organization
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {number} [offset] pagination offset
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listDomains(
      xRhInsightsRequestId?: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDomainsResponseSchema>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listDomains(xRhInsightsRequestId, offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Request the information for a specific domain of our organization.
     * @summary Read a domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readDomain(
      uuid: string,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.readDomain(uuid, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Register a domain in the current organization.
     * @summary Register a domain.
     * @param {string} xRhIdmRegistrationToken One-time password to authenticate domain registration with ipa-hcc command.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {RegisterDomainRequest} registerDomainRequest Domain object to be registered.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerDomain(
      xRhIdmRegistrationToken: string,
      xRhIdmVersion: string,
      registerDomainRequest: RegisterDomainRequest,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainRegisterResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerDomain(
        xRhIdmRegistrationToken,
        xRhIdmVersion,
        registerDomainRequest,
        xRhInsightsRequestId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update the rhel-idm domain information.
     * @summary Update domain information by user.
     * @param {string} uuid The uuid that identify the domain.
     * @param {UpdateDomainUserRequest} updateDomainUserRequest Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDomainUser(
      uuid: string,
      updateDomainUserRequest: UpdateDomainUserRequest,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainUser(uuid, updateDomainUserRequest, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ResourcesApiFp(configuration);
  return {
    /**
     * Request a domain registration token
     * @summary Domain registration token request
     * @param {DomainRegTokenRequest} domainRegTokenRequest Domain registration request
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomainToken(domainRegTokenRequest: DomainRegTokenRequest, xRhInsightsRequestId?: string, options?: any): AxiosPromise<DomainRegToken> {
      return localVarFp.createDomainToken(domainRegTokenRequest, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
    /**
     * Delete an existing domain from the current organization.
     * @summary Delete domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain(uuid: string, xRhInsightsRequestId?: string, options?: any): AxiosPromise<void> {
      return localVarFp.deleteDomain(uuid, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get signing keys and revokation information
     * @summary Signing keys
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSigningKeys(xRhInsightsRequestId?: string, options?: any): AxiosPromise<SigningKeysResponse> {
      return localVarFp.getSigningKeys(xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
    /**
     * For the current organization, list all the domains that are being managed from console.dot
     * @summary List domains in the organization
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {number} [offset] pagination offset
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDomains(xRhInsightsRequestId?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListDomainsResponseSchema> {
      return localVarFp.listDomains(xRhInsightsRequestId, offset, limit, options).then((request) => request(axios, basePath));
    },
    /**
     * Request the information for a specific domain of our organization.
     * @summary Read a domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDomain(uuid: string, xRhInsightsRequestId?: string, options?: any): AxiosPromise<DomainResponse> {
      return localVarFp.readDomain(uuid, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
    /**
     * Register a domain in the current organization.
     * @summary Register a domain.
     * @param {string} xRhIdmRegistrationToken One-time password to authenticate domain registration with ipa-hcc command.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {RegisterDomainRequest} registerDomainRequest Domain object to be registered.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerDomain(
      xRhIdmRegistrationToken: string,
      xRhIdmVersion: string,
      registerDomainRequest: RegisterDomainRequest,
      xRhInsightsRequestId?: string,
      options?: any
    ): AxiosPromise<DomainRegisterResponse> {
      return localVarFp
        .registerDomain(xRhIdmRegistrationToken, xRhIdmVersion, registerDomainRequest, xRhInsightsRequestId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update the rhel-idm domain information.
     * @summary Update domain information by user.
     * @param {string} uuid The uuid that identify the domain.
     * @param {UpdateDomainUserRequest} updateDomainUserRequest Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDomainUser(
      uuid: string,
      updateDomainUserRequest: UpdateDomainUserRequest,
      xRhInsightsRequestId?: string,
      options?: any
    ): AxiosPromise<DomainResponse> {
      return localVarFp.updateDomainUser(uuid, updateDomainUserRequest, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
  /**
   * Request a domain registration token
   * @summary Domain registration token request
   * @param {DomainRegTokenRequest} domainRegTokenRequest Domain registration request
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public createDomainToken(domainRegTokenRequest: DomainRegTokenRequest, xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .createDomainToken(domainRegTokenRequest, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete an existing domain from the current organization.
   * @summary Delete domain.
   * @param {string} uuid The uuid that identify the domain.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteDomain(uuid: string, xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteDomain(uuid, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get signing keys and revokation information
   * @summary Signing keys
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getSigningKeys(xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getSigningKeys(xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * For the current organization, list all the domains that are being managed from console.dot
   * @summary List domains in the organization
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {number} [offset] pagination offset
   * @param {number} [limit] Number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public listDomains(xRhInsightsRequestId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .listDomains(xRhInsightsRequestId, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Request the information for a specific domain of our organization.
   * @summary Read a domain.
   * @param {string} uuid The uuid that identify the domain.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public readDomain(uuid: string, xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .readDomain(uuid, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Register a domain in the current organization.
   * @summary Register a domain.
   * @param {string} xRhIdmRegistrationToken One-time password to authenticate domain registration with ipa-hcc command.
   * @param {string} xRhIdmVersion ipa-hcc agent version
   * @param {RegisterDomainRequest} registerDomainRequest Domain object to be registered.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public registerDomain(
    xRhIdmRegistrationToken: string,
    xRhIdmVersion: string,
    registerDomainRequest: RegisterDomainRequest,
    xRhInsightsRequestId?: string,
    options?: AxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .registerDomain(xRhIdmRegistrationToken, xRhIdmVersion, registerDomainRequest, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update the rhel-idm domain information.
   * @summary Update domain information by user.
   * @param {string} uuid The uuid that identify the domain.
   * @param {UpdateDomainUserRequest} updateDomainUserRequest Information for an IPA domain so it is updated from the ipa-hcc agent.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public updateDomainUser(
    uuid: string,
    updateDomainUserRequest: UpdateDomainUserRequest,
    xRhInsightsRequestId?: string,
    options?: AxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .updateDomainUser(uuid, updateDomainUserRequest, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
